// Update the peak values of edge buffer.  ATTENTION only the cell
// value that have data (bit0 is true) and the boundary cells (bit 31
// mask true) are considered.
// WARNING compute the absolute value.

CA_FUNCTION updatePEAKE(CA_GRID grid, CA_EDGEBUFF_REAL_IO PEAK, CA_EDGEBUFF_REAL_I SRC, 
			CA_CELLBUFF_STATE_I MASK)
{
  // Initialise the grid
  CA_GRID_INIT(grid);

  // Create the array which will contain the src edges.
  CA_ARRAY_CREATE(grid, CA_REAL, SRCE, caEdges+1);

  // Create the array which will contain the peak edges.
  CA_ARRAY_CREATE(grid, CA_REAL, PEAKE, caEdges+1);

  // Retrive the index of the main cell.
  CA_INDEX index = caIndex(grid, 0);

  // Read Mask.
  CA_STATE mask  = caReadCellBuffState(grid,MASK,index);

  // Read bit 0  (false the main cell has nodata)
  CA_STATE bit0  = caReadBitsState(mask,0,1);

  // Read bit 31 (true if the main cell is nodata in at least one
  // neighbour has data)
  CA_STATE bit31  = caReadBitsState(mask,31,32);

  // If the main cell has no data and none of the neighbour has data,
  // then do nothing.
  if(bit0 == 0 && bit31 == 0)
    return;

  // Read the edges of the main cell.
  caReadEdgeBuffRealEdgeArray(grid, SRC, index, SRCE);

  // Read the edges of the peak values.
  caReadEdgeBuffRealEdgeArray(grid, PEAK, index, PEAKE);

  // Loop through the edges.
  for(int e=1; e<=caEdges; e++)
  {
    if(e<=caUpdateEdges(grid))
    {
      // Get the maximum.
      CA_REAL  max = caMaxReal(SRCE[e],PEAKE[e]);
     
      // Update the maximum value.
      caWriteEdgeBuffReal(grid,PEAK,e,max);
    }
  }    
}
